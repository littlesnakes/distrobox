#!/bin/sh
# POSIX
# Expected env variables:
#	HOME
#	USER
#	DISTROBOX_ENTER_PATH

trap '[ "$?" -ne 0 ] && echo An error occurred' EXIT

# Defaults
container_app=""
container_export_delete=0
container_service=""
extra_flags=""
verbose=0
version="distrobox_version_placeholder"

# We depend on some commands, let's be sure we have them
base_dependencies="basename grep sed find"
for dep in ${base_dependencies}; do
	if ! command -v "${dep}" >/dev/null; then
		echo "Missing dependency: ${dep}"
		exit 127
	fi
done

# Print usage to stdout.
# Arguments:
#   None
# Outputs:
#   print usage with examples.
show_help() {
	echo "USAGE:
	distrobox version: ${version}

	distrobox-export --app mpv
	distrobox-export --service syncthing
	distrobox-export --bin /path/to/bin --export-path ~/.local/bin

	Note you can use --app OR --service OR --bin but not together.

	Arguments:
		--app/-a:		name of the application to export
		--bin/-b:		name of the application to export
		--service/-s:		name of the service to export
		--delete/-d:		delete exported application or service
		--export-path/-ep:	name of the application to export
		--extra-flags/-ef:		extra flags to add to the command
		--help/-h:		show this message
		--verbose/-v:			show more verbosity
		--version/-V:			show version
	"
}

# Print generated script from template
# Arguments:
#	distrobox name
#	binary path
# Outputs:
#   print generated script.
generate_script() {
	distrobox_name=$1
	binary_path=$2
	echo "#!/bin/sh
# distrobox_binary
# name: ${distrobox_name}
if [ ! -f /run/.containerenv ]; then
    distrobox-enter --name ${distrobox_name} -e ${binary_path} ${extra_flags} \$@
else
    ${binary_path} \$@
fi"
}

# Parse arguments
while :; do
	case $1 in
	-h | --help)
		# Call a "show_help" function to display a synopsis, then exit.
		show_help
		exit
		;;
	-v | --verbose)
		shift
		verbose=1
		;;
	-V | --version)
		echo "distrobox: ${version}"
		exit
		;;
	-a | --app)
		if [ -n "$2" ]; then
			container_app="$2"
			shift
			shift
		fi
		;;
	-b | --bin)
		if [ -n "$2" ]; then
			container_bin="$2"
			shift
			shift
		fi
		;;
	-s | --service)
		if [ -n "$2" ]; then
			container_service="$2"
			shift
			shift
		fi
		;;
	-d | --delete)
		container_export_delete=1
		shift
		;;
	-ep | --export-path)
		if [ -n "$2" ]; then
			dest_path="$2"
			shift
			shift
		fi
		;;
	-ef | --extra-flags)
		if [ -n "$2" ]; then
			extra_flags="$2"
			shift
			shift
		fi
		;;
	*) # Default case: If no more options then break out of the loop.
		break ;;
	esac
done
# Ensure the foundamental variables are set and not empty, we will not proceed if
# they are not all set.
if [ -z "${container_app}" ] &&
	[ -z "${container_bin}" ] &&
	[ -z "${container_service}" ]; then
	echo "Invalid arguments, choose an action below"
	show_help
	exit 1
fi
if [ -n "${container_app}" ] &&
	[ -n "${container_bin}" ] &&
	[ -n "${container_service}" ]; then
	echo "Invalid arguments, choose only one action below"
	show_help
	exit 1
fi
if [ -n "${container_bin}" ] && [ -z "${dest_path}" ]; then
	echo "Missing argument export-path"
	exit 1
fi

# Also check we're running inside a container and not on the host
if [ ! -f /run/.containerenv ]; then
	echo "You must run $(basename "$0") inside a container..."
	exit 1
fi

set -o errexit
set -o nounset
# set verbosity
if [ "${verbose}" -ne 0 ]; then
	set -o xtrace
fi

container_name=$(grep "name=" /run/.containerenv | cut -d'"' -f2)
# Prefix to add to an existing command to work throught the container
container_command_prefix="${DISTROBOX_ENTER_PATH:-"distrobox-enter"} --name ${container_name} -e "

if [ -n "${container_bin}" ]; then
	# Work on a binary export

	# Ensure the binary we're exporting is installed
	if [ ! -f "${container_bin}" ]; then
		echo "Error: cannot find ${container_bin}"
		exit 127
	fi
	# generate dest_file path
	dest_file="${dest_path}/$(basename "${container_bin}")"

	# If we're deleting it, just do it and exit
	if [ "${container_export_delete}" -ne 0 ] && grep -q "distrobox_binary" "${dest_file}"; then
		rm -f "${dest_file}"
		exit 0
	fi

	# test if we have writing rights on the file
	if ! touch "${dest_file}"; then
		echo "Error: cannot create destination file ${dest_file}"
		exit 1
	fi

	# create the script from template and write to file
	generate_script "${container_name}" "${container_bin}" >"${dest_file}"
	chmod +x "${dest_file}"

	exit 0

elif [ -n "${container_app}" ]; then
	# Work on a desktop app export

	# Ensure the app we're exporting is installed
	if ! command -v "${container_app}" >/dev/null; then
		echo "Error: trying to export a non-installed application"
		exit 127
	fi
	# Find desktop file for the application to export
	desktop_files=$(grep -ril "${container_app}" /usr/share/applications/*)
	icon_files=$(find /usr/share/icons -iname "*${container_app}*")

	# copy icons in home directory
	for icon in ${icon_files}; do
		icon_home_folder="$(dirname "${icon}" | sed "s|/usr/share/|${HOME}/.local/share/|g")"

		# check if we're exporting or deleting
		if [ "${container_export_delete}" -ne 0 ]; then
			# we need to remove, not export
			rm -f "${icon_home_folder}"/"$(basename "${icon}")"
		else
			# we wanto to export the application's icons
			mkdir -p "${icon_home_folder}"
			cp "${icon}" "${icon_home_folder}"
		fi
	done

	# create desktop files for the distrobox
	for desktop_file in ${desktop_files}; do
		desktop_home_file="$(basename "${desktop_file}")"

		# check if we're exporting or deleting
		if [ "${container_export_delete}" -ne 0 ]; then
			rm -f "${HOME}/.local/share/applications/${desktop_home_file}"
		else
			# If a TryExec is present, we have to fake it as it will not work throught the
			# container separation
			sed "s|^Exec=|Exec=${container_command_prefix} |g" "${desktop_file}" |
				sed "s|\(%.*\)|${extra_flags} \1|g" |
				sed "s|^TryExec=.*|TryExec=true|g" \
					>"${HOME}/.local/share/applications/${desktop_home_file}"
		fi
	done

	exit 0

elif [ -n "${container_service}" ]; then
	# Work on a service export

	# If we're managing services, let's be sure we have systemctl
	if ! command -v systemctl >/dev/null; then
		echo "Missing dependency: systemd"
		exit 127
	fi

	# Ensure we're working with fresh data
	systemctl --user daemon-reload

	# Fetch original service file
	service_file="${HOME}/.config/systemd/user/${container_service}.service"

	# If we're deleting it, just do it and exit
	if [ "${container_export_delete}" -ne 0 ]; then
		rm -f "${HOME}/.config/systemd/user/${container_service}.service"
		systemctl --user daemon-reload
		exit 0
	fi

	# Create temp file with random name
	temp_file="/tmp/$(
		tr -dc A-Za-z0-9 </dev/urandom | head -c 13
		echo ''
	)"
	# Replace all Exec occurrencies
	for cmd in ExecStart ExecStartPre ExecStartPost ExecReload ExecStop ExecStopPost; do
		# Save to temp file
		systemctl --user cat "${container_service}.service" >"${temp_file}" 2>/dev/null
		# Add prefix only if not present
		if ! grep "${cmd}" "${temp_file}" | grep -q "${container_command_prefix}"; then
			tail -n+2 "${temp_file}" |
				sed "s|^${cmd}=|${cmd}=${container_command_prefix} |g" |
				sed "s|^${cmd}=.*|& ${extra_flags}|g" >"${service_file}"
		fi
	done
	# Cleanup
	rm -f "${temp_file}"
	# Reload
	systemctl --user daemon-reload

	exit 0
fi
